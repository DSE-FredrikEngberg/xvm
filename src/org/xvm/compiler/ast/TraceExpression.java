package org.xvm.compiler.ast;


import org.xvm.asm.Argument;
import org.xvm.asm.Constant;
import org.xvm.asm.Constant.Format;
import org.xvm.asm.ConstantPool;
import org.xvm.asm.ErrorListener;
import org.xvm.asm.MethodStructure.Code;

import org.xvm.asm.constants.IdentityConstant;
import org.xvm.asm.constants.MethodConstant;
import org.xvm.asm.constants.PropertyConstant;
import org.xvm.asm.constants.TypeConstant;

import org.xvm.asm.op.GP_Sub;
import org.xvm.asm.op.Invoke_01;
import org.xvm.asm.op.P_Get;

import org.xvm.util.PackedInteger;


/**
 * An expression that holds a copy of the result of another expression in order to provide optional
 * traceability.
 */
public class TraceExpression
        extends SyntheticExpression
    {
    // ----- constructors --------------------------------------------------------------------------

    /**
     * Construct a TraceExpression.
     *
     * @param expr  the expression to trace
     */
    public TraceExpression(Expression expr)
        {
        super(expr);

        assert expr.isValidated();

        Constant val = null;
        if (expr.isConstant())
            {
            // TODO
            }

        finishValidation(null, expr.pool().typeInt(), expr.getTypeFit().addConversion(), val, errs);
        }


    // ----- accessors -----------------------------------------------------------------------------


    // ----- Expression compilation ----------------------------------------------------------------


    @Override
    protected boolean hasSingleValueImpl()
        {
        return expr.hasSingleValueImpl();
        }

    @Override
    protected boolean hasMultiValueImpl()
        {
        return expr.hasMultiValueImpl();
        }

    @Override
    public TypeConstant getImplicitType(Context ctx)
        {
        return getType();
        }

    @Override
    public TypeConstant[] getImplicitTypes(Context ctx)
        {
        return getTypes();
        }

    @Override
    protected Expression validate(Context ctx, TypeConstant typeRequired, ErrorListener errs)
        {
        return this;
        }

    @Override
    protected Expression validateMulti(Context ctx, TypeConstant[] atypeRequired, ErrorListener errs)
        {
        return this;
        }

    @Override
    public void generateVoid(Context ctx, Code code, ErrorListener errs)
        {
        expr.generateVoid(ctx, code, errs);
        }

    @Override
    public Argument generateArgument(
            Context ctx, Code code, boolean fLocalPropOk, boolean fUsedOnce, ErrorListener errs)
        {
        return !isConstant() &&
                ? expr.generateArgument(ctx, code, fLocalPropOk, fUsedOnce, errs)
                : super.generateArgument(ctx, code, fLocalPropOk, fUsedOnce, errs);
        }

    @Override
    public Argument[] generateArguments(Context ctx, Code code, boolean fLocalPropOk,
            boolean fUsedOnce, ErrorListener errs)
        {
        if (hasMultiValueImpl())
            {
            // TODO
            }

        return super.generateArguments(ctx, code, fLocalPropOk, fUsedOnce, errs);
        }

    @Override
    public void generateAssignment(Context ctx, Code code, Assignable LVal, ErrorListener errs)
        {
        if (isConstant())
            {
            super.generateAssignment(ctx, code, LVal, errs);
            }

        // TODO extract the value from the underlying expression
        Argument argExtracted = expr.generateArgument(ctx, code, false, true, errs);
        if (idExtract != null)
            {
            Argument   argExtractFrom = argExtracted;
            Assignable LValExtractTo  = createTempVar(code, getType(), true, errs);
            argExtracted = LValExtractTo.getLocalArgument();
            code.add(idExtract instanceof PropertyConstant
                    ? new P_Get((PropertyConstant) idExtract, argExtractFrom, argExtracted)
                    : new Invoke_01(argExtractFrom, (MethodConstant) idExtract, argExtracted));
            }

        LVal.assign(argAdjusted, code, errs);
        }


    // ----- debugging assistance ------------------------------------------------------------------

    @Override
    public String toString()
        {
        return expr.toString();
        }


    // ----- fields --------------------------------------------------------------------------------

    /**
     * The arguments generated by the underlying expression.
     */
    private Argument[] m_args;
    }
