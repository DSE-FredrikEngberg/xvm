PARSER-01 = Unknown fatal parser error: \"{0}\".
PARSER-02 = Unexpected End-Of-File (token exhaustion).
PARSER-03 = Expected token {0}; found {1}.
PARSER-04 = Bad version value.
PARSER-05 = Bad hex character: {0}.
PARSER-06 = Unsupported custom literal type: \"{0}\".
PARSER-07 = Cannot have module or package in a method.
PARSER-08 = Multiple assignment list required.
PARSER-09 = Empty statement is illegal.
PARSER-10 = Illegal assert designation: \"{0}\".
PARSER-11 = Conditional not allowed in a switch statement.
PARSER-12 = Case statement required first in a switch.
PARSER-13 = Assignment not allowed.
PARSER-14 = Either all clauses are conditional (":"), or none are.
PARSER-15 = Either all dimensions have values, or none may.
PARSER-16 = Unexpected token: {0}. (Expected an EOF.)
PARSER-17 = Expected to find a type declaration.
PARSER-18 = No statements allowed outside of module declaration.
PARSER-19 = Repeated modifier: \"{0}\".
PARSER-20 = Conflicting modifiers: \"{0}\", \"{1}\".
PARSER-21 = Default switch branch is repeated.
PARSER-22 = Expression does not represent an L-Value.

LEXER-03  = Invalid character:
LEXER-04  = Illegal number:

COMPILER-01 = Unknown fatal compiler error. {0}
COMPILER-02 = Cannot nest a module.
COMPILER-03 = Package cannot be nested under \"{0}\".
COMPILER-04 = Class cannot be nested under \"{0}\".
COMPILER-05 = Property \"{0}\" is a duplicate.
COMPILER-06 = Property \"{0}\" cannot be nested under \"{1}\".
COMPILER-07 = Illegal module name.
COMPILER-08 = Duplicate modifier.
COMPILER-09 = Illegal modifier.
COMPILER-10 = Conflicting modifier.
COMPILER-11 = More than one "extends" clause.
COMPILER-12 = Illegal / unexpected type parameters.
COMPILER-13 = Illegal / unexpected constructor parameters.
COMPILER-14 = Illegal / unexpected constructor parameters.
COMPILER-15 = Unexpected keyword.
COMPILER-16 = Inner const class must be declared static if its outer class is not a const.
COMPILER-17 = Inner service class must be declared static if its outer class is not a const or service.
COMPILER-18 = Wrong number of type parameter values.
COMPILER-19 = Type parameter name is a duplicate.
COMPILER-20 = More than one "import" clause.
COMPILER-21 = More than one "into" clause.
COMPILER-22 = Package cannot have both body and "import" clause.
COMPILER-23 = A conditional is not allowed on this structure.
COMPILER-24 = Cannot find a module.
COMPILER-25 = Conflicting version clauses.
COMPILER-26 = An import of the primary module cannot specify import modifiers or versions.
COMPILER-27 = Illegal link-time conditional expression.
COMPILER-28 = Duplicate import with the same alias: \"{0}\".
COMPILER-29 = Import cannot be conditional; condition ignored.
COMPILER-30 = Unresolvable name: \"{0}\".
COMPILER-31 = Name collision: \"{0}\".
COMPILER-32 = Not a class type: \"{0}\".
COMPILER-33 = Method \"{0}\" cannot be nested under \"{1}\".
COMPILER-34 = Typedef \"{0}\" cannot be nested under \"{1}\".
COMPILER-35 = Annotation cannot occur here.
COMPILER-36 = Could not find name \"{0}\" within \"{1}\".
COMPILER-37 = Name \"{0}\" is ambiguous.
COMPILER-38 = Name \"{0}\" is unresolvable.
COMPILER-39 = Name \"{0}\" is unhideable; attempt to hide \"{1}\" is an error.
COMPILER-40 = Return is supposed to be void.
COMPILER-41 = Return is supposed to be non-void.
COMPILER-42 = Return has the wrong number of arguments: {0} expected, {1} found.
COMPILER-43 = Type mismatch: {0} expected, {1} found.
COMPILER-44 = Wrong number of values: {0} expected, {1} found.
COMPILER-45 = Value of type \"{0}\" is out of range: {1}.
COMPILER-46 = Statement is not reachable.
COMPILER-47 = Expression does not evaluate to a constant value.
COMPILER-48 = A value is required.
COMPILER-49 = A return is required.
COMPILER-50 = Invalid operation.
COMPILER-51 = Variable \"{0}\" is already defined.
COMPILER-52 = No \"this\" is available.
COMPILER-53 = No \"super\" function is available.
COMPILER-54 = Unexpected redundant return type information.
COMPILER-55 = Method or function type requires complete parameter and return type information.
COMPILER-56 = Could not find a matching method or function \"{0}\".
COMPILER-57 = Could not find an \"outer this\" named \"{0}\".
COMPILER-58 = Unexpected method name \"{0}\" encountered.
COMPILER-59 = The \".this\" suffix must follow a parent class or parent property identity.
COMPILER-60 = Because a previous argument specified a parameter name, the argument {0} must specify a parameter name
COMPILER-61 = No matching annotation constructor.
COMPILER-62 = No-parameter constructor required for \"{0}\".
COMPILER-63 = Signature \"{0}\" is ambiguous.
COMPILER-64 = Type \"{0}\" has more than one default value for the type.
COMPILER-65 = Could not find a matching constructor for type \"{0}\".
COMPILER-66 = Tuple type has an unexpected number of field types; {0} expected, {1} found.
COMPILER-67 = Expression yields the type \"{1}\" that does not support the \"{0}\" operator.
COMPILER-68 = Expression yields the type \"{1}\" that does not support the \"{0}\" operator with the {2} specified parameters.
COMPILER-69 = The use of the \"{0}\" operator does not resolve to a single, unambiguous operator signature on the type \"{1}\".
COMPILER-70 = The expression cannot be assigned to.
COMPILER-71 = The left-hand-side of the Elvis expression is not nullable.
COMPILER-72 = The left-hand-side of the Elvis expression is only nullable.
COMPILER-73 = Short-circuiting expressions are not allowed in this context.
COMPILER-74 = The expression on the left-hand-side of the colon does not have the potential to use the expression on the right-hand-side.
COMPILER-75 = A \"switch\" can only contain one \"default\" statement.
COMPILER-76 = A \"switch\" expression must contain a \"default\" statement.
COMPILER-77 = The \"switch\" contains more than one \"case\" statement for the value: \"{0}\".
COMPILER-78 = A \"switch\" requires a constant value for the \"case\" statement.
COMPILER-79 = A \"switch\" must begin with a \"case\" statement.
COMPILER-80 = A \"switch\" expression cannot end with a \"case\" statement.
COMPILER-81 = The variable \"{0}\" is not definitely assigned.
COMPILER-82 = The variable \"{0}\" cannot be assigned to.
COMPILER-83 = Name required.
COMPILER-84 = Wrong number of arguments: {0} expected, {1} found.
COMPILER-85 = Parameter name is a duplicate: \"{0}\".
COMPILER-86 = Parameter types must be specified.
COMPILER-87 = Auto-narrowing override ('!') is not allowed.
COMPILER-88 = Could not find the specified label \"{0}\".
COMPILER-89 = Could not find an enclosing \"for\", \"do\", \"while\", or \"switch\" statement.
COMPILER-90 = A \"continue\" statement can only be applied to an enclosing \"for\", \"do\", \"while\", or \"switch\" statement.
COMPILER-91 = The expression type is not nullable: \"{0}\".
COMPILER-92 = The types \"{0}\" and \"{1}\" are not comparable.
COMPILER-93 = A duplicate name is used for the label \"{0}\".
COMPILER-94 = The specified label variable \"{0}\" is not available for the label \"{1}\".
COMPILER-95 = Index value {0} out-of-range; must be between {1} and {2} (inclusive).
COMPILER-NI = \"{0}\" is not yet implemented.

VERIFY-01 = Unknown fatal verifier error: \"{0}\".
VERIFY-02 = \"{0}\" does not have type parameters, but type parameters were provided.
VERIFY-03 = \"{0}\" requires \"{1}\" type parameters, but \"{2}\" type parameters were provided.
VERIFY-04 = \"{0}\" type parameter \"{1}\" must be of type \"{2}\", but has been overridden as \"{3}\" by {4}.
VERIFY-05 = \"{0}\" type parameter \"{1}\" must be of type \"{2}\", but has been specified as \"{3}\" by {4}.
VERIFY-06 = \"{0}\" type parameter \"{1}\" is specified as two different types (\"{2}\" and \"{3}\") by {4}.
VERIFY-07 = \"{0}\" is annotated by type \"{1}\", but it is not an explicit class identity.
VERIFY-08 = Unexpected "extends" \"{0}\" on \"{1}\"; an "extends" specifier cannot occur on interfaces (or on the root Object), there must be only one, and it must occur first (after any annotations, and after the "into" for a mixin).
VERIFY-09 = \"{0}\" is missing "extends".
VERIFY-10 = \"{0}\" "extends" \"{1}\", but it is not an explicit class identity.
VERIFY-11 = \"{0}\" is part of a cyclical "extends" loop.
VERIFY-12 = \"{0}\" mixes into \"{1}\", but is extended by \"{2}\" that mixes into the incompatible type \"{3}\".
VERIFY-13 = Unexpected annotation \"{0}\" on \"{1}\"; annotations can only appear in the beginning of the contribution list.
VERIFY-14 = Unexpected "into" \"{0}\" on \"{1}\"; an "into" specifier can only occur on a mixin, there must be only one, and it must occur first (after any annotations).
VERIFY-15 = Unexpected "incorporates" \"{0}\" on \"{1}\"; an "incorporates" specifier cannot occur on an interface.
VERIFY-16 = \"{0}\" is incorporated by type \"{1}\", but it is not an explicit class identity.
VERIFY-17 = \"{0}\" is incorporated by type \"{1}\", but it is not a mixin.
VERIFY-18 = \"{0}\" incorporates \"{1}\", but \"{2}\" is not compatible with the "into" specifier: \"{3}\".
VERIFY-19 = \"{0}\" is delegated by type \"{1}\", but it is not an interface type.
VERIFY-20 = \"{0}\" is implemented by type \"{1}\", but it is not an interface type.
VERIFY-21 = Unexpected "delegates" \"{0}\" on \"{1}\"; a "delegates" specifier cannot occur on an interface.
VERIFY-22 = Unexpected formal type name \"{0}\" encountered while resolving \"{1}\".
VERIFY-23 = \"{0}\", which is a \"{1}\", illegally extends \"{2}\", which is a \"{3}\".
VERIFY-24 = Service type \"{0}\" cannot be treated as an immutable type.
VERIFY-25 = Redundant immutable type specification.
VERIFY-26 = Type \"{0}\" cannot be annotated because it does not specify a class or interface.
VERIFY-27 = \"{0}\" is not a mixin, and thus cannot be used in an annotation.
VERIFY-28 = The annotation \"@{0}\" can only occur once.
VERIFY-29 = Type \"{0}\" cannot have accessibility defined because it does not specify a class or interface.
VERIFY-30 = \"{0}\" is extended by mixin type \"{1}\", but it is not a mixin.
VERIFY-31 = \"{0}\" is not a type that can be parameterized.
VERIFY-32 = \"{0}\" is annotated by \"{1}\", but is not compatible with the required \"into\": \"{2}\".
VERIFY-33 = \"{0}\" type parameter \"{1}\" is of type \"{2}\", which conflicts with the type parameter contribution from \"{3}\" of type \"{4}\".
VERIFY-34 = \"{0}\" type parameter \"{1}\" is not specified, which conflicts with the type parameter contribution from \"{2}\" of type \"{3}\".
VERIFY-35 = \"{0}\" type parameter \"{1}\" is of type \"{2}\", which conflicts with the type parameter contribution from \"{3}\" of the unspecified type.
VERIFY-36 = \"{0}\" contains a property \"{1}\" which collides with a type parameter of the same name.
VERIFY-37 = \"{0}\" missing a property \"{1}\" for the type parameter of the same name.
VERIFY-38 = \"{0}\" has a misconfigured property \"{1}\" for the type parameter of the same name.
VERIFY-39 = The \"{0}\" property on \"{1}\" is annotated by \"{2}\", which is an incompatible mixin for a property.
VERIFY-40 = The \"get()\" method on the \"{1}\" property on \"{0}\" is ambiguous.
VERIFY-41 = The \"get()\" method on the \"{1}\" property on \"{0}\" does not match the property type.
VERIFY-42 = The \"set()\" method on the \"{1}\" property on \"{0}\" is ambiguous.
VERIFY-43 = The \"set()\" method on the \"{1}\" property on \"{0}\" does not match the property type.
VERIFY-44 = Interface \"{0}\" contains an illegal property declaration for \"{1}\": Interface properties cannot include an implementation.
VERIFY-45 = Interface \"{0}\" contains an illegal property declaration for \"{1}\": Interface properties cannot include Ref or Var annotations.
VERIFY-46 = Interface \"{0}\" contains an illegal property declaration for \"{1}\": Interface properties must not specify @Inject.
VERIFY-47 = Property \"{0}\" overrides the property \"{1}\", so it must specify @Override.
VERIFY-48 = \"{0}\" contains an @RO property \"{1}\" that has a \"set()\" that uses a Var annotation or \"super\".
VERIFY-49 = \"{0}\" contains an @Inject property \"{1}\"  that also implements \"get()\", \"set()\", or has a Ref or Var annotation.
VERIFY-50 = \"{0}\" contains an @RO property \"{1}\" that does not have a "get()" and is not annotated with "@Abstract", "@Override", or "@Inject".
VERIFY-51 = \"{0}\" contains an @Override property \"{1}\", but no property declaration exists to override.
VERIFY-52 = \"{0}\" contains a duplicate annotation: \"{1}\".
VERIFY-53 = \"{0}\" contains a duplicate incorporates clause: \"{1}\".
VERIFY-54 = \"{0}\" contains a duplicate delegates clause: \"{1}\".
VERIFY-55 = \"{0}\" contains a duplicate implements clause: \"{1}\".
VERIFY-56 = The property \"{1}\" on \"{0}\" contains a duplicate initializer function.
VERIFY-57 = The constant property \"{1}\" on \"{0}\" contains custom code.
VERIFY-58 = The access for the \"{1}\" property on \"{0}\" is illegally specified as "struct".
VERIFY-59 = The Ref access is more restricted than the Var access for the \"{1}\" property on \"{0}\".
VERIFY-60 = The constant property \"{1}\" on \"{0}\" does not have an initial value.
VERIFY-61 = The constant property \"{1}\" on \"{0}\" has more than one initial value.
VERIFY-62 = The constant property \"{1}\" on \"{0}\" is declared as @Abstract.
VERIFY-63 = The constant property \"{1}\" on \"{0}\" is declared as a read/write property.
VERIFY-64 = The declaration of the \"{1}\" property on \"{0}\" implies both a read-only and a read/write property.
VERIFY-65 = The super method for \"{0}\" is ambiguous.
VERIFY-66 = Property information for \"{0}\" contains both a regular property and a type parameter.
VERIFY-67 = Property information for \"{0}\" contains conflicting types \"{1}\" and \"{2}\".
VERIFY-68 = Property information for \"{0}\" contains conflicting constant information.
VERIFY-69 = \"{0}\" contains multiple methods that attempt to narrow \"{1}\", including \"{2}\"; only a single narrowing method can exist, unless the method being narrowed is also extended without being narrowed, such that it remains accessible.
VERIFY-70 = A super method for \"{0}\" on \"{1}\" is indicated by the "@Override" annotation, but cannot be found.
VERIFY-71 = The interface property \"{1}\" on \"{0}\" is declared as @Abstract; that annotation is not permitted.
VERIFY-72 = An annotation on the constant \"{1}\" on \"{0}\" is illegal: Constants cannot include Ref or Var annotations.
VERIFY-73 = The @Override annotation on the constant \"{1}\" on \"{0}\" is illegal.
VERIFY-74 = The function \"{0}\" contains a property \"{1}\"; functions must not contain properties.
VERIFY-75 = The annotation \"{2}\" on property \"{1}\" on \"{0}\" duplicates an annotation that is already present from the base property; the annotation on the derived property is ignored.
VERIFY-76 = The annotation \"{2}\" on property \"{1}\" on \"{0}\" is a super-class of the annotation \"{3}\" that is already present from the base property; the annotation on the derived property is ignored.
VERIFY-77 = The property \"{1}\" on \"{0}\" attempts to declare a Var property, but the setter on the base is private.
VERIFY-78 = Interface \"{0}\" contains an illegal property declaration for \"{1}\": An interface property must be declared as @RO to specify a default get() implementation.
VERIFY-79 = The access for the \"{1}\" property on \"{0}\" is defined more restrictively than its base.
VERIFY-80 = \"{0}\" attempts to override the method \"{1}\" on \"{2}\", but the method cannot be overridden.
VERIFY-81 = \"{0}\" attempts to override the method \"{1}\" on \"{2}\", but does not specify @Override.
VERIFY-82 = \"{0}\" is not an instantiable abstract type.
VERIFY-83 = \"{0}\" is not an instantiable singleton type.
VERIFY-84 = \"{0}\" is not an instantiable type because it contains an abstract property "{1}".
VERIFY-85 = \"{0}\" is not an instantiable type because it contains an abstract method "{1}".
VERIFY-90 = \"{0}\" requires a parent instance in order to be instantiated.
VERIFY-91 = \"{0}\" cannot be instantiated using a parent instance.
VERIFY-92 = \"{0}\" is not related to the provided parent instance type \"{1}\".
