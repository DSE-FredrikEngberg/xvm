// fundamentals
+NOP                                                ; traditional no-op, which does nothing
 LINE_1                                             ; advance line counter
 LINE_N      #lines                                 ; advance line counter
 BREAK                                              ; explicit break-point for debugger
+ENTER                                              ; variable scope begin
+EXIT                                               ; variable scope end
+GUARD       #handlers:(CLASS_CONST, CONST_STRING, rel_addr)
                                                    ; try { (+ “catch” class, var name, handler address)
                                                    ;       // note: ENTER
+END_GUARD   rel_addr                               ; } ... // note: EXIT (
+HANDLER                                            ; begin an exception handler (implicit ENTER and an exception var)
+END_HANDLER rel-addr                               ; finish an exception handler with a jump // note: EXIT
+GUARD_ALL   rel-addr                               ; try { (+ "finally" address // note: ENTER
+FINALLY                                            ; begin a "finally" handler (implicit EXIT/ENTER and an exception var)
+END_FINALLY                                        ; finish a "finally" handler // note: EXIT
+THROW       rvalue                                 ; raise exception

// jumps
+GOTO       abs-addr                                ; unconditional absolute jump
+JMP        rel-addr                                ; unconditional relative jump
+JMP_TRUE   rvalue-bool, rel-addr                   ; jump if value is true
+JMP_FALSE  rvalue-bool, rel-addr                   ; jump if value is false
+JMP_ZERO   rvalue-int, rel-addr                    ; jump if value is zero
+JMP_NZERO  rvalue-int, rel-addr                    ; jump if value is NOT zero
+JMP_NULL   rvalue, rel-addr                        ; jump if value is null
+JMP_NNULL  rvalue, rel-addr                        ; jump if value is NOT null
+JMP_EQ     rvalue, rvalue, rel-addr                ; jump if value is equal
+JMP_NEQ    rvalue, rvalue, rel-addr                ; jump if value is NOT equal
+JMP_LT     rvalue, rvalue, rel-addr                ; jump if value is less than
+JMP_LTE    rvalue, rvalue, rel-addr                ; jump if value is less than or equal
+JMP_GT     rvalue, rvalue, rel-addr                ; jump if value is greater than
+JMP_GTE    rvalue, rvalue, rel-addr                ; jump if value is greater than or equal
 JMP_TYPE   rvalue, rvalue-type, rel-addr           ; jump if type of the value is “instanceof" specified type
 JMP_NTYPE  rvalue, rvalue-type, rel-addr           ; jump if type of the value is NOT “instanceof" specified type

// variables and refs
+VAR        TYPE_CONST                              ; next register is an uninitialized anonymous variable
+IVAR       TYPE_CONST, rvalue-src                  ; next register is an initialized anonymous variable
+NVAR       TYPE_CONST, CONST_STRING                ; next register is an uninitialized named variable
+INVAR      TYPE_CONST, CONST_STRING, rvalue-src    ; next register is an initialized named variable
+DVAR       CONST_REF_CLASS                         ; next register is an anonymous "dynamic reference" variable
+DNVAR      CONST_REF_CLASS, CONST_STRING           ; next register is a named "dynamic reference" variable
+SVAR       TYPE_CONST, #values:(rvalue-src)        ; next register is an initialized anonymous Sequence variable
+TVAR       #values:(TYPE_CONST, rvalue-src)        ; next register is an initialized anonymous Tuple variable
+REF        lvalue                                  ; next register represents the Variable ref for the specified variable
 CREF       rvalue                                  ; next register represents the @ro Variable ref for the specified variable
 CAST       rvalue, TYPE_CONST                      ; next register holds the type-casted value
+MOV        rvalue-src, lvalue-dest                 ; move source value to destination
+MOV_REF    lvalue-src, lvalue-dest                 ; move reference-to-source to destination
 MOV_CREF   rvalue-src, lvalue-dest                 ; move reference-to-source to destination
 MOV_CAST   rvalue-src, lvalue-dest, TYPE_CONST     ; move type-casted source reference to destination
 SWAP       lvalue, lvalue                          ; swap source and destination values

// register-based operations;
// in this group either rvalue could be a constant
+ADD        rvalue-target, rvalue-second, lvalue-return                             ; T + T -> T
 SUB        rvalue-target, rvalue-second, lvalue-return                             ; T - T -> T
 MUL        rvalue-target, rvalue-second, lvalue-return                             ; T * T -> T
 DIV        rvalue-target, rvalue-second, lvalue-return                             ; T / T -> T
 MOD        rvalue-target, rvalue-second, lvalue-return                             ; T % T -> T
 SHL        rvalue-target, rvalue-second, lvalue-return                             ; T << Int -> T
 SHR        rvalue-target, rvalue-second, lvalue-return                             ; T >> Int -> T
 USHR       rvalue-target, rvalue-second, lvalue-return                             ; T >>> Int -> T
 AND        rvalue-target, rvalue-second, lvalue-return                             ; T & T -> T
 OR         rvalue-target, rvalue-second, lvalue-return                             ; T | T -> T
 XOR        rvalue-target, rvalue-second, lvalue-return                             ; T ^ T -> T
 DIVMOD     rvalue-target, rvalue-second, lvalue-div-return, lvalue-mod-return      ; T /% T -> T, T
 POS        rvalue-target, lvalue-return                                            ; +T -> T                ; TODO make this reserved? (it’s a no-op for built-in types)
+NEG        rvalue-target, lvalue-return                                            ; -T -> T
 COMPL      rvalue-target, lvalue-return                                            ; ~T -> T                ; WHY DOES THIS EXIST?

// in this group, the lvalue-target could be either a positive number, representing
// a register, or a negative - representing a local CONST_PROPERTY
+POSTINC    lvalue-target, lvalue-return                                            ; T++ -> T
 POSTDEC    lvalue-target, lvalue-return                                            ; T-— -> T
+PREINC     lvalue-target, lvalue-return                                            ; ++T -> T
 PREDEC     lvalue-target, lvalue-return                                            ; --T -> T
 ADD_ASGN   lvalue-target, rvalue-second                                            ; T += T
 SUB_ASGN   lvalue-target, rvalue-second                                            ; T -= T
 MUL_ASGN   lvalue-target, rvalue-second                                            ; T *= T
 DIV_ASGN   lvalue-target, rvalue-second                                            ; T /= T
 MOD_ASGN   lvalue-target, rvalue-second                                            ; T %= T
 SHL_ASGN   lvalue-target, rvalue-second                                            ; T <<= Int
 SHR_ASGN   lvalue-target, rvalue-second                                            ; T >>= Int
 USHR_ASGN  lvalue-target, rvalue-second                                            ; T >>>= Int
 AND_ASGN   lvalue-target, rvalue-second                                            ; T &= T
 OR_ASGN    lvalue-target, rvalue-second                                            ; T |= T
 XOR_ASGN   lvalue-target, rvalue-second                                            ; T ^= T

// property ops
+P_GET        rvalue-target, CONST_PROPERTY, lvalue-return  ; get property
+P_SET        rvalue-target, CONST_PROPERTY, rvalue         ; set property
 P_REF        rvalue-target, CONST_PROPERTY                 ; next register represents the Property ref for the specified property
 P_CREF       rvalue-target, CONST_PROPERTY                 ; next register represents the @ro Property ref for the specified property
 P_INC        rvalue-target, CONST_PROPERTY                 ; in-place increment; no result
 P_DEC        rvalue-target, CONST_PROPERTY                 ; ditto
+P_POSTINC    rvalue-target, CONST_PROPERTY, lvalue-return  ; same as POSTINC for a register
 P_POSTDEC    rvalue-target, CONST_PROPERTY, lvalue-return  ; ditto
+P_PREINC     rvalue-target, CONST_PROPERTY, lvalue-return
 P_PREDEC     rvalue-target, CONST_PROPERTY, lvalue-return
 P_ADD_ASGN   lvalue-target, CONST_PROPERTY, rvalue-second
 P_SUB_ASGN   lvalue-target, CONST_PROPERTY, rvalue-second
 P_MUL_ASGN   lvalue-target, CONST_PROPERTY, rvalue-second
 P_DIV_ASGN   lvalue-target, CONST_PROPERTY, rvalue-second
 P_MOD_ASGN   lvalue-target, CONST_PROPERTY, rvalue-second
 P_SHL_ASGN   lvalue-target, CONST_PROPERTY, rvalue-second
 P_SHR_ASGN   lvalue-target, CONST_PROPERTY, rvalue-second
 P_USHR_ASGN  lvalue-target, CONST_PROPERTY, rvalue-second
 P_AND_ASGN   lvalue-target, CONST_PROPERTY, rvalue-second
 P_OR_ASGN    lvalue-target, CONST_PROPERTY, rvalue-second
 P_XOR_ASGN   lvalue-target, CONST_PROPERTY, rvalue-second

// local property based
+L_GET      CONST_PROPERTY, lvalue                 ; local get property (target=this)
+L_SET      CONST_PROPERTY, rvalue                 ; local set property (target=this)
 L_REF      CONST_PROPERTY                         ; next register represents the Property ref for the specified local property (target=this)

// function calls
+CALL_00    rvalue-function
+CALL_01    rvalue-function, lvalue-return
 CALL_0N    rvalue-function, #returns:(lvalue)
 CALL_0T    rvalue-function, lvalue-return-tuple
+CALL_10    rvalue-function, rvalue-param
+CALL_11    rvalue-function, rvalue-param, lvalue-return
+CALL_1N    rvalue-function, rvalue-param, #returns:(lvalue)
+CALL_1T    rvalue-function, rvalue-param, lvalue-return-tuple
+CALL_N0    rvalue-function, #params:(rvalue)
+CALL_N1    rvalue-function, #params:(rvalue), lvalue-return
 CALL_NN    rvalue-function, #params:(rvalue), #returns:(lvalue)
 CALL_NT    rvalue-function, #params:(rvalue), lvalue-return-tuple
 CALL_T0    rvalue-function, rvalue-params-tuple
 CALL_T1    rvalue-function, rvalue-params-tuple, lvalue-return
 CALL_TN    rvalue-function, rvalue-params-tuple, #returns:(lvalue)
 CALL_TT    rvalue-function, rvalue-params-tuple, lvalue-return-tuple

// method calls
+INVOKE_00  rvalue-target, CONST-METHOD
+INVOKE_01  rvalue-target, CONST-METHOD, lvalue-return
+INVOKE_0N  rvalue-target, CONST-METHOD, #returns:(lvalue)
+INVOKE_0T  rvalue-target, CONST-METHOD, lvalue-return-tuple
+INVOKE_10  rvalue-target, CONST-METHOD, rvalue-param
+INVOKE_11  rvalue-target, CONST-METHOD, rvalue-param, lvalue-return
+INVOKE_1N  rvalue-target, CONST-METHOD, rvalue-param, #returns:(lvalue)
+INVOKE_1T  rvalue-target, CONST-METHOD, rvalue-param, lvalue-return-tuple
+INVOKE_N0  rvalue-target, CONST-METHOD, #params:(rvalue)
+INVOKE_N1  rvalue-target, CONST-METHOD, #params:(rvalue), lvalue-return
+INVOKE_NN  rvalue-target, CONST-METHOD, #params:(rvalue), #returns:(lvalue)
 INVOKE_NT  rvalue-target, CONST-METHOD, #params:(rvalue), lvalue-return-tuple
 INVOKE_T0  rvalue-target, CONST-METHOD, rvalue-params-tuple
+INVOKE_T1  rvalue-target, CONST-METHOD, rvalue-params-tuple, lvalue-return
 INVOKE_TN  rvalue-target, CONST-METHOD, rvalue-params-tuple, #returns:(lvalue)
 INVOKE_TT  rvalue-target, CONST-METHOD, rvalue-params-tuple, lvalue-return-tuple

// index-based (array/tuple) ops
+I_GET        rvalue-target, rvalue-index, lvalue-return        ; T = T[Ti]
+I_SET        rvalue-target, rvalue-index, rvalue-new-value     ; T[Ti] = T
+I_REF        rvalue-target, rvalue-index, lvalue-return        ; Ref<T> = &T[Ti]
 I_CREF       rvalue-target, rvalue-index, lvalue-return        ; @ro Ref<T> = &T[Ti]
 I_INC        rvalue-target, rvalue-index                       ; same as INC for a property
 I_DEC        rvalue-target, rvalue-index                       ; same as DEC for a property
 I_POSTINC    rvalue-target, rvalue-index, lvalue-return        ; same as POSTINC for a property
 I_POSTDEC    rvalue-target, rvalue-index, lvalue-return        ; ditto
+I_PREINC     rvalue-target, rvalue-index, lvalue-return
 I_PREDEC     rvalue-target, rvalue-index, lvalue-return
 I_ADD_ASGN   lvalue-target, rvalue-index, rvalue-second
 I_SUB_ASGN   lvalue-target, rvalue-index, rvalue-second
 I_MUL_ASGN   lvalue-target, rvalue-index, rvalue-second
 I_DIV_ASGN   lvalue-target, rvalue-index, rvalue-second
 I_MOD_ASGN   lvalue-target, rvalue-index, rvalue-second
 I_SHL_ASGN   lvalue-target, rvalue-index, rvalue-second
 I_SHR_ASGN   lvalue-target, rvalue-index, rvalue-second
 I_USHR_ASGN  lvalue-target, rvalue-index, rvalue-second
 I_AND_ASGN   lvalue-target, rvalue-index, rvalue-second
 I_OR_ASGN    lvalue-target, rvalue-index, rvalue-second
 I_XOR_ASGN   lvalue-target, rvalue-index, rvalue-second

// construction
 NEW_0      CONST-CONSTRUCT, lvalue-return
+NEW_1      CONST-CONSTRUCT, rvalue-param, lvalue-return
+NEW_N      CONST-CONSTRUCT, #params:(rvalue), lvalue-return
 NEW_T      CONST-CONSTRUCT, rvalue-params-tuple, lvalue-return
+NEW_0G     CONST-CONSTRUCT, rvalue-type, lvalue-return                             ; generic "new"
+NEW_1G     CONST-CONSTRUCT, rvalue-type, rvalue-param, lvalue-return
+NEW_NG     CONST-CONSTRUCT, rvalue-type, #params:(rvalue), lvalue-return
 NEW_TG     CONST-CONSTRUCT, rvalue-type, rvalue-params-tuple, lvalue-return
 NEWC_0     CONST-CONSTRUCT, rvalue-parent, lvalue-return                           ; virtual "new" for child classes
 NEWC_1     CONST-CONSTRUCT, rvalue-parent, rvalue-param, lvalue-return
 NEWC_N     CONST-CONSTRUCT, rvalue-parent, #params:(rvalue), lvalue-return
 NEWC_T     CONST-CONSTRUCT, rvalue-parent, rvalue-type, rvalue-params-tuple, lvalue-return
 NEWC_0G    CONST-CONSTRUCT, rvalue-parent, rvalue-type, lvalue-return              ; virtual generic "new" for child classes
 NEWC_1G    CONST-CONSTRUCT, rvalue-parent, rvalue-type, rvalue-param, lvalue-return
 NEWC_NG    CONST-CONSTRUCT, rvalue-parent, rvalue-type, #params:(rvalue), lvalue-return
 NEWC_TG    CONST-CONSTRUCT, rvalue-parent, rvalue-params-tuple, lvalue-return
 CONSTR_0   CONST-CONSTRUCT                                                         ; "super" construct call
+CONSTR_1   CONST-CONSTRUCT, rvalue-param
+CONSTR_N   CONST-CONSTRUCT, #params:(rvalue)
 CONSTR_T   CONST-CONSTRUCT, rvalue-params-tuple

 RTYPE_1    CLASS_TYPE_CONST, rvalue-type, lvalue-return                    ; resolve generic type; lvalue-return - a Type object
 RTYPE_N    CLASS_TYPE_CONST, #type-params:(rvalue-type), lvalue-return
 MATCH_2    rvalue, CONST_*, rel-addr, CONST_*, rel-addr                    ; if the value equals one of the two constants, jump accordingly
 MATCH_3    rvalue, CONST_*, rel-addr, CONST_*, rel-addr, CONST_*, rel-addr ; if the value equals one of the three constants, jump accordingly
 MATCH_N    rvalue, #opts:(CONST_*, rel-addr)                               ; if the value equals one of the N constants, jump accordingly
+ASSERT     rvalue                                  ; assert
+ASSERT_T   rvalue, CONST_STRING                    ; assert with assertion text (e.g. assertion expression)
+ASSERT_V   rvalue, CONST_STRING, #vals(rvalue)     ; assert with assertion text and variables to print
+MBIND      rvalue-target, CONST-METHOD, lvalue-fn-result
+FBIND      rvalue-fn, #params:(param-index, rvalue-param), lvalue-fn-result
 FBINDN     rvalue-fn, #params:(CONST_STRING, rvalue-param), lvalue-fn-result ; TODO is this something that could be deferred or eliminated???
+RETURN_0                                                                   ; return (no return value)
+RETURN_1   rvalue                                                          ; return (single return value)
+RETURN_N   #vals:(rvalue)                                                  ; return (multiple return value)
+RETURN_T   rvalue-tuple                                                    ; return (multiple return from a tuple)

// Boolean checks
+IS_ZERO    rvalue-int, lvalue-return               ; T == 0 -> Boolean
+IS_NZERO   rvalue-int, lvalue-return               ; T != 0 -> Boolean
+IS_NULL    rvalue, lvalue-return                   ; T == null -> Boolean
+IS_NNULL   rvalue, lvalue-return                   ; T != null -> Boolean
+IS_EQ      rvalue, rvalue, lvalue-return           ; T == T -> Boolean
+IS_NEQ     rvalue, rvalue, lvalue-return           ; T != T -> Boolean
+IS_LT      rvalue, rvalue, lvalue-return           ; T < T -> Boolean
+IS_LTE     rvalue, rvalue, lvalue-return           ; T <= T -> Boolean
+IS_GT      rvalue, rvalue, lvalue-return           ; T > T -> Boolean
+IS_GTE     rvalue, rvalue, lvalue-return           ; T >= T -> Boolean
+IS_NOT     rvalue, lvalue-return                   ; !T -> Boolean
 IS_TYPE    rvalue, rvalue-type, lvalue-return      ; T instanceof Type -> Boolean
 IS_NTYPE   rvalue, rvalue-type, lvalue-return      ; !(T instanceof Type) -> Boolean
 IS_SVC     rvalue                                  ; (T is a service) -> Boolean
 IS_CONST   rvalue                                  ; (T is a const) -> Boolean
 IS_IMMT    rvalue                                  ; (T is an immutable) -> Boolean


// conditions
 COND       CONST_COND                              ; specified condition is true      // note: ENTER
 NCOND      CONST_COND                              ; specified condition is false     // note: ENTER
 ACOND                                              ; assertions enabled               // note: ENTER
 NACOND                                             ; assertions not enabled           // ...
 TCOND                                              ; test mode enabled (implies assertions enabled)
 NTCOND                                             ; test mode not enabled
 DCOND                                              ; running in debugger
 NDCOND                                                                                                      ; not running in debugger
 PCOND      (CONST_MODULE | CONST_NAMESPACE | CLASS_CONST | CONST_METHOD | CONST_PROPERTY | CONST_STRING)    ; VM-structure or named condition present
 NPCOND     (CONST_MODULE | CONST_NAMESPACE | CLASS_CONST | CONST_METHOD | CONST_PROPERTY | CONST_STRING)    ; VM-structure or named condition absent
 VCOND      (CONST_MODULE | CONST_NAMESPACE | CLASS_CONST | CONST_METHOD | CONST_PROPERTY), CONST_VER        ; VM-structure of a (>=) specified version present
 NVCOND     (CONST_MODULE | CONST_NAMESPACE | CLASS_CONST | CONST_METHOD | CONST_PROPERTY), CONST_VER        ;                   (<)
 XCOND      CONST_VER                                                                                        ; XVM of a (>=) specified version present
 NXCOND     CONST_VER                                                                                        ;          (<)
 END_COND                                                                                                    ; end conditional block         // note: EXIT


pre-defined variables/constants:
+ 0: this
+ 1: this:public
+ 2: this:protected
+ 3: this:private
+ 4: this:target
+ 5: this:struct
  6: this:frame     Frame
+ 7: this:service	Service + ..
+ 8: this:module    Module + ..
  9: this:type      Type
+ A: super          Function
