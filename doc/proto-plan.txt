+ super() method call

+ Service
        - cleanup an un-referenced service (phantom refs?)
        +/- container terminates when all services are stopped

+ Function wrapping for services
+ Get/Set on the service

+ Matching the function/method return value with a Ref

+ FutureRef async completion handling

+ Atomics

+ Vars as "deferrable" registers

+ Arrays, Generic types

+ Refs to array elements

+ Refs to method arguments

+ DaemonPool scheduling - "native" stack implementation

+ Tuple, ConditionalTuple

+ Tuple construction - new TVAR, SVAR op-codes

+ Service reentrancy, timeouts and Fibers

+ injection

+ native Service methods

+ Multi:
    +- new
    +- call
    +- invoke

+ try-finally

+ op-code serialization/deserialization

+ introduce "native super" in ClassTemplate to allow Object -> MyClass -> MyService inheritance

+ Const

+ hash implementation

+ revisit hash and to<String> implementation

+ change the continuation API

+ implement missing enum methods

+ mixin processing

+ revisit PreInc, PostInc; add Inc, Dec ops

+ use of the MethodSignature instead of MethodConstant

+ re-work ops:
    + Merge Ref and MoveRef
    + Move, Ref - allow next unallocated register;
    + allow local property for Invoke_*
    + allow next register and local property for GP_Add, GP_NEG
    + allow local property for Call_*
    + allow local property for PIP_*
    + allow local property for Call_* and Invoke_* returns
    + allow local property for l-values (assignValue)
    + allow next register for *GET
    + allow local property for IS_*
    + allow local property for JMP_*
    + allow local property for GP_*
    + allow local property for IP_*
    + allow local property for IIP_*
    + allow next register for IS_*
    + allow next register for Invoke_*
    + allow next register for Call_*

+ change tests using "local property" mode

+ access exchange (public vs private vs struct) during invocations

+ change VAR_S to be consistent with VAR_T op (TYPE = Sequence type)

+ createConst() processing for Array

+ singleton initialization contracts
    + singletons represented by constants (SingletonConstant)
    + initialization during the frame construction based on a transient
      "initialized" flag on the MethodStructure
    + circular initialization check

+ ClassTemplate - check for @Op for Add, Sub, ...

+ generate the default constructor

+ isA() to support auto-narrowing types
    - add a test for auto-narrowing method invocation
    + Tuple, Function (and Method?) have to have specialized "isA" algorithms

+ changed the Service API - Void registerAsyncSection(AsyncSection asyncSection);
    - pending futures are kept along with the corresponding AsyncSection
    - registerAsyncSection blocks

- add a ReentrantLock for the ServiceContext to allow for an optimistic (message-less) context switch
    - DaemonPool to acquire the lock prior to nextFiber() call
    - ServiceContext.sendXyz() to set a target ServiceContext reference that would be used by
      DaemonPool to attempt to switch to another context
    - native code should be able to tryLock another context for a quick operation
      (e.g. Buffer<Byte> to be locked by a FileChannel)

- Stack overflow (fiber depth + frame depth within a fiber or cross-fiber frame depth)

- createConst() processing for Set, Map etc.

- Property and Method native implementation

- Class, Type native implementation

- a new VAR_D like op-code to provide additional parameters (e.g. injection name)

- introduce stock exception (Bounds, IllegalState, etc.)

- introduce native functions

- Type: by-method comparison

- Move op-code: "safe wrapper" logic

- ServiceContext - the "register..." APIs are "fiber local" -- unless called from the outside

- TypeInfo.findCallable() - use the same approach as Expression.findMethod()

- ast.Annotation - use the InvocationExpression's approach for argument validation

- AssignmentStatement - narrow Nullable type if possible (deferred due to loops and reference taking
  complications)

- create native xBitArray

+ implement default argument constant calculation (currently always zero value)

+ runtime support for property initializer "="

- native optimization Stringable methods on xInt*, xUInt*, etc.

- consider a FormalTypeConstant instead of TerminalType(PropertyConstant)

-- review the argument generation approach (regarding stack, and local prop) for all ops that use
   Frame.getArguments() similar to InvocationExpression and NewExpression

$$$$$$$$$$ DEFERRED ISSUES $$$$$$$$$$$$$$$

- TemplateRegistry and TypeComposition could be mutated by different threads
    (hence the use of ConcurrentHashMap in TemplateRegistry and synchronization in TypeComposition)

