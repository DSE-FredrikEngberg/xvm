- test static property with value (both constant and init function)

- verify that inner structs are getting created correctly:
  - inner class
  - class in a method
  - method in a method
  - lambda in a method
  - static property in a method
  - method in a property
  - property in a property
  - class in a property

- auto conversion
  x IntLiteral - > Int, ok
  - IntLiteral[] -> Int[] ???
  - Tuple(String, IntLiteral) -> Tuple(String, Int) ???

- tests
  x return 40 + 2
  x "void" was messing up test (so was "int" for gene)
  - props: should NOT be able to combine constants, type params, and props
  - props: should NOT be able to re-introduce setter if super is unreachable
  - props: "delegates" should default Ref / Var -
  - props: nested inside other props, methods
  - props: implicit never getting set for either props or methods? test "into"
  - props: "invoke non virtual" question from gene regarding public/private implementation (in the presence of virtual collisions)

- TypeInfo
  - nested / scoped stuff
    - static props in methods must be private
  - methods
  - constructors
  - immutable types (const, enum, module, package) should have @RO for public/protected/private props
    - but yet still have Var with field for struct, unless otherwise suppressed

- Doc
  - type system - no terminals - why it's completely different
  - "free" objects, e.g. properties, array/tuple/function of this
  - arrays of structs - how a handle could indicate type of "Person" vs. "Person as an array element"
    (with any of them identifiable as: type="Person as an array element", array ref, index)
  - arrays of columns vs. rows (SIMD opts) -- could just be two different types

Contributions and call chains:
- In the case of interfaces, there are three forms of contributions:
  (i)   the declarative and default-implementation contents of the interface itself (internally
        using an "equals" contribution);
  (ii)  other interface types via "implements" contributions (note that the source code uses the
        "extends" keyword, but the compiled result uses "implements"); and
  (iii) a special "into" contribution of the base Object class, which allows the default method code
        on an interface to be compiled with the implicit presence of the members of the Object class.
- While "interface types" are often interfaces, there are several other ways to specify an interface
  type, all of which hold declarative members, but none of which has the ability to provide default
  member implementations:
  (i)   a "difference type" is always an interface type;
  (ii)  an "intersection type" always yields an interface type (in addition to yielding two separate
        constraint types); and
  (iii) a "union type" of types 'a' and 'b' yields an interface type iff both 'a' and 'b' are
        interface types.
- Mixins have a dramatically larger set of contributions available:
  (i)   the members of the mixin itself (internally using an "equals" contribution);
  (ii)  extends mixin (optional)
  (iii) incorporates (including conditional mix-in)
  (iv)  annotated-by
  (v)   delegates interface type(s)
  (vi)  implements interface type(s)
  (vii) into -
- Classes have a similar set of call chains, lacking "into" (since classes are not "mixed into"
  anything) and adding a "rebases onto" contribution for specialized classes, such as "const" and
  "service" types:
  (i)   the members of the class itself (internally using an "equals" contribution);
  (ii)  extends class (except that Object does not extend anything)
  (iii) rebases-onto
  (iv)  incorporates (including conditional mix-in)
  (v)   annotated-by
  (vi)  delegates interface type(s)
  (vii) implements interface type(s)
- Properties also have call chains.
  ( ) the members of the property, referred to as "custom code";
  ( ) the Ref/Var annotations on the property;
  ( ) delegates (from the containing type);
  ( ) "rebase onto" or "mixes into" Ref/Var.
  ( ) default implementation of get() from an interface

--

TypeInfo: AccessType{type=Ecstasy:Object:private} (format=CLASS, newable)
- Class Chain (1)
  [0] Ecstasy:Object (Anchored)
- Properties (1)
  [0] (v) Property{property=meta}=Ecstasy:Meta<this:class:public, this:class:protected, this:class:private> meta
    [0] Ecstasy:Meta<this:class:public, this:class:protected, this:class:private> meta; (id=Ecstasy:Object.meta, impl=Explicit, @Inject)
- Methods (5)
  [0] (v) Method{name=to, signature=Ecstasy:String to()}=Ecstasy:String to()
    [0] Object.to() {sig=Ecstasy:String to(), impl=Explicit}
  [1] (v) Method{name=to, signature=Ecstasy:collections.Array<this:class> to()}=Ecstasy:collections.Array<this:class> to()
    [0] Object.to() {sig=Ecstasy:collections.Array<this:class> to(), impl=Explicit}
  [2] (v) Method{name=to, signature=Ecstasy:collections.Tuple<this:class> to()}=Ecstasy:collections.Tuple<this:class> to()
    [0] Object.to() {sig=Ecstasy:collections.Tuple<this:class> to(), impl=Explicit}
  [3] (v) Method{name=to, signature=Ecstasy:Function<Ecstasy:collections.Tuple<this:class>, Ecstasy:collections.Tuple> to()}=Ecstasy:Function<Ecstasy:collections.Tuple<this:class>, Ecstasy:collections.Tuple> to()
    [0] Object.to() {sig=Ecstasy:Function<Ecstasy:collections.Tuple<this:class>, Ecstasy:collections.Tuple> to(), impl=Explicit}
  [4] Method{name=equals, signature=Ecstasy:Boolean equals(Ecstasy:Object, Ecstasy:Object)}=Ecstasy:Boolean equals(Ecstasy:Object, Ecstasy:Object)
    [0] Object.equals(Ecstasy:Object, Ecstasy:Object) {sig=Ecstasy:Boolean equals(Ecstasy:Object, Ecstasy:Object), impl=Explicit}

--

Test:DumpC1 - notice redundancy of some methods pre/post resolve (is this a bug that we need to worry about?)

TypeInfo: AccessType{type=Test:DumpC1:private} (format=CLASS, abstract)
- Parameters (2)
  [0] RefType=<Ecstasy:Int64>
  [1] y.RefType=<Ecstasy:Int64>
- Extends: Ecstasy:Object
- Class Chain (2)
  [0] Test:DumpC1 (Anchored)
  [1] Ecstasy:Object
- Default Chain (1)
  [0] Test:I
- Properties (22)
  [0] (v) Property{property=x#selfContained}=Ecstasy:Boolean selfContained
    [0] Ecstasy:Boolean selfContained; (id=Ecstasy:Ref.selfContained, impl=Implicit, RO)
  [1] (v) Property{property=y#meta}=Ecstasy:Meta<this:class:public, this:class:protected, this:class:private> meta
    [0] Ecstasy:Meta<this:class:public, this:class:protected, this:class:private> meta; (id=Ecstasy:Object.meta, impl=Implicit)
  [2] (v) Property{property=y#service_}=Ecstasy:Boolean service_
    [0] Ecstasy:Boolean service_; (id=Ecstasy:Referent.service_, impl=Implicit, RO)
  [3] (v) Property{property=x#const_}=Ecstasy:Boolean const_
    [0] Ecstasy:Boolean const_; (id=Ecstasy:Referent.const_, impl=Implicit, RO)
  [4] (v) Property{property=y#RefType}=Ecstasy:Type<Ecstasy:Object> RefType
    [0] Ecstasy:Type<Ecstasy:Object> RefType; (id=Ecstasy:Ref.RefType, impl=Native, type-param, RO)
  [5] (v) Property{property=x#immutable_}=Ecstasy:Boolean immutable_
    [0] Ecstasy:Boolean immutable_; (id=Ecstasy:Referent.immutable_, impl=Implicit, RO)
  [6] (v) Property{property=meta}=Ecstasy:Meta<this:class:public, this:class:protected, this:class:private> meta
    [0] Ecstasy:Meta<this:class:public, this:class:protected, this:class:private> meta; (id=Ecstasy:Object.meta, impl=Explicit, @Inject)
  [7] (v) Property{property=y#ActualType}=Ecstasy:Type ActualType
    [0] Ecstasy:Type ActualType; (id=Ecstasy:Ref.ActualType, impl=Implicit, RO)
  [8] (v) Property{property=y#assigned}=Ecstasy:Boolean assigned
    [0] Ecstasy:Boolean assigned; (id=Ecstasy:Ref.assigned, impl=Implicit, RO)
  [9] (v) Property{property=y#name}=Ecstasy:Nullable | Ecstasy:String name
    [0] Ecstasy:Nullable | Ecstasy:String name; (id=Ecstasy:Ref.name, impl=Implicit, RO)
  [10] (v) Property{property=x#byteLength}=Ecstasy:Int64 byteLength
    [0] Ecstasy:Int64 byteLength; (id=Ecstasy:Ref.byteLength, impl=Implicit, RO)
  [11] (v) Property{property=y}=Ecstasy:Int64 y, require-field
    [0] Ecstasy:Int64 y; (id=Test:DumpC1.y, impl=Explicit, RW, has-field, has-code)
  [12] (v) Property{property=x}=Ecstasy:Int64 x, require-field
    [0] Ecstasy:Int64 x; (id=Test:I.x, impl=SansCode, has-field, @RO)
    [1] Ecstasy:Int64 x; (id=Test:I.x, impl=Declared, RO, has-code, @RO)
  [13] (v) Property{property=x#service_}=Ecstasy:Boolean service_
    [0] Ecstasy:Boolean service_; (id=Ecstasy:Referent.service_, impl=Implicit, RO)
  [14] (v) Property{property=x#RefType}=Ecstasy:Type<Ecstasy:Object> RefType
    [0] Ecstasy:Type<Ecstasy:Object> RefType; (id=Ecstasy:Ref.RefType, impl=Native, type-param, RO)
  [15] (v) Property{property=x#name}=Ecstasy:Nullable | Ecstasy:String name
    [0] Ecstasy:Nullable | Ecstasy:String name; (id=Ecstasy:Ref.name, impl=Implicit, RO)
  [16] (v) Property{property=y#selfContained}=Ecstasy:Boolean selfContained
    [0] Ecstasy:Boolean selfContained; (id=Ecstasy:Ref.selfContained, impl=Implicit, RO)
  [17] (v) Property{property=y#const_}=Ecstasy:Boolean const_
    [0] Ecstasy:Boolean const_; (id=Ecstasy:Referent.const_, impl=Implicit, RO)
  [18] (v) Property{property=x#assigned}=Ecstasy:Boolean assigned
    [0] Ecstasy:Boolean assigned; (id=Ecstasy:Ref.assigned, impl=Implicit, RO)
  [19] (v) Property{property=x#ActualType}=Ecstasy:Type ActualType
    [0] Ecstasy:Type ActualType; (id=Ecstasy:Ref.ActualType, impl=Implicit, RO)
  [20] (v) Property{property=y#immutable_}=Ecstasy:Boolean immutable_
    [0] Ecstasy:Boolean immutable_; (id=Ecstasy:Referent.immutable_, impl=Implicit, RO)
  [21] (v) Property{property=y#byteLength}=Ecstasy:Int64 byteLength
    [0] Ecstasy:Int64 byteLength; (id=Ecstasy:Ref.byteLength, impl=Implicit, RO)
- Methods (39)
  [0] (v) Method{name=y#set, signature=Void set(Ecstasy:Var.RefType)}=Void set(Ecstasy:Int64)
    [*] Var.set(Ecstasy:Var.RefType) {sig=Void set(Ecstasy:Int64), impl=Implicit}
  [1] (v) Method{name=y#set, signature=Void set(Ecstasy:annotations.LazyVar.RefType)}=Void set(Ecstasy:Int64)
    [0] annotations.LazyVar.set(Ecstasy:annotations.LazyVar.RefType) {sig=Void set(Ecstasy:Int64), impl=Explicit}
  [2] (v) Method{name=x#revealAs, signature=(Ecstasy:Boolean, AsType) revealAs(Ecstasy:Type<Ecstasy:Object>)}=(Ecstasy:Boolean, AsType) revealAs(Ecstasy:Type<Ecstasy:Object>)
    [*] Referent.revealAs(Ecstasy:Type<Ecstasy:Object>) {sig=(Ecstasy:Boolean, AsType) revealAs(Ecstasy:Type<Ecstasy:Object>), impl=Implicit}
  [3] Method{name=y#equals, signature=Ecstasy:Boolean equals(Ecstasy:Object, Ecstasy:Object)}=Ecstasy:Boolean equals(Ecstasy:Object, Ecstasy:Object)
    [0] Object.equals(Ecstasy:Object, Ecstasy:Object) {sig=Ecstasy:Boolean equals(Ecstasy:Object, Ecstasy:Object), impl=Explicit}
  [4] Method{name=y#equals, signature=Ecstasy:Boolean equals(Ecstasy:Ref, Ecstasy:Ref)}=Ecstasy:Boolean equals(Ecstasy:Ref, Ecstasy:Ref)
    [*] Ref.equals(Ecstasy:Ref, Ecstasy:Ref) {sig=Ecstasy:Boolean equals(Ecstasy:Ref, Ecstasy:Ref), impl=Default}
  [5] (v) Method{name=x#extends_, signature=Ecstasy:Boolean extends_(Ecstasy:Class)}=Ecstasy:Boolean extends_(Ecstasy:Class)
    [*] Referent.extends_(Ecstasy:Class) {sig=Ecstasy:Boolean extends_(Ecstasy:Class), impl=Implicit}
  [6] (v) Method{name=x#implements_, signature=Ecstasy:Boolean implements_(Ecstasy:Class)}=Ecstasy:Boolean implements_(Ecstasy:Class)
    [*] Referent.implements_(Ecstasy:Class) {sig=Ecstasy:Boolean implements_(Ecstasy:Class), impl=Implicit}
  [7] (v) Method{name=y#incorporates_, signature=Ecstasy:Boolean incorporates_(Ecstasy:Class)}=Ecstasy:Boolean incorporates_(Ecstasy:Class)
    [*] Referent.incorporates_(Ecstasy:Class) {sig=Ecstasy:Boolean incorporates_(Ecstasy:Class), impl=Implicit}
  [8] (v) Method{name=x#instanceOf, signature=Ecstasy:Boolean instanceOf(Ecstasy:Type)}=Ecstasy:Boolean instanceOf(Ecstasy:Type)
    [*] Referent.instanceOf(Ecstasy:Type) {sig=Ecstasy:Boolean instanceOf(Ecstasy:Type), impl=Implicit}
  [9] (v) Method{name=x#peek, signature=(Ecstasy:Boolean, Ecstasy:Ref.RefType) peek()}=(Ecstasy:Boolean, Ecstasy:Int64) peek()
    [*] Ref.peek() {sig=(Ecstasy:Boolean, Ecstasy:Int64) peek(), impl=Implicit}
  [10] Method{name=equals, signature=Ecstasy:Boolean equals(Ecstasy:Object, Ecstasy:Object)}=Ecstasy:Boolean equals(Ecstasy:Object, Ecstasy:Object)
    [0] Object.equals(Ecstasy:Object, Ecstasy:Object) {sig=Ecstasy:Boolean equals(Ecstasy:Object, Ecstasy:Object), impl=Explicit}
  [11] (v) Method{name=x#get, signature=Ecstasy:Ref.RefType get()}=Ecstasy:Int64 get()
    [0] Ref.get() {sig=Ecstasy:Int64 get(), impl=Capped, target=Ecstasy:Int64 get()}
    [*] Ref.get() {sig=Ecstasy:Int64 get(), impl=Implicit}
  [12] (v) Method{name=x#get, signature=Ecstasy:Int64 get()}=Ecstasy:Int64 get()
    [*] I.x.get() {sig=Ecstasy:Int64 get(), impl=Default}
    [*] Ref.get() {sig=Ecstasy:Int64 get(), impl=Implicit}
  [13] (v) Method{name=x#to, signature=Ecstasy:String to()}=Ecstasy:String to()
    [*] Object.to() {sig=Ecstasy:String to(), impl=Implicit}
  [14] (v) Method{name=x#to, signature=Ecstasy:collections.Array<this:class> to()}=Ecstasy:collections.Array<this:class> to()
    [*] Object.to() {sig=Ecstasy:collections.Array<this:class> to(), impl=Implicit}
  [15] (v) Method{name=x#to, signature=Ecstasy:collections.Tuple<this:class> to()}=Ecstasy:collections.Tuple<this:class> to()
    [*] Object.to() {sig=Ecstasy:collections.Tuple<this:class> to(), impl=Implicit}
  [16] (v) Method{name=x#to, signature=Ecstasy:Function<Ecstasy:collections.Tuple<this:class>, Ecstasy:collections.Tuple> to()}=Ecstasy:Function<Ecstasy:collections.Tuple<this:class>, Ecstasy:collections.Tuple> to()
    [*] Object.to() {sig=Ecstasy:Function<Ecstasy:collections.Tuple<this:class>, Ecstasy:collections.Tuple> to(), impl=Implicit}
  [17] (v) Method{name=y#calc, signature=Ecstasy:annotations.LazyVar.RefType calc()}=Ecstasy:Int64 calc()
    [0] annotations.LazyVar.calc() {sig=Ecstasy:Int64 calc(), impl=Capped, target=Ecstasy:Int64 calc()}
    [1] annotations.LazyVar.calc() {sig=Ecstasy:Int64 calc(), impl=Explicit}
  [18] (v) Method{name=y#calc, signature=Ecstasy:Int64 calc()}=Ecstasy:Int64 calc()
    [0] DumpC1.y.calc() {sig=Ecstasy:Int64 calc(), impl=Explicit}
    [1] annotations.LazyVar.calc() {sig=Ecstasy:Int64 calc(), impl=Explicit}
  [19] (v) Method{name=y#maskAs, signature=AsType maskAs(Ecstasy:Type<Ecstasy:Object>)}=AsType maskAs(Ecstasy:Type<Ecstasy:Object>)
    [*] Referent.maskAs(Ecstasy:Type<Ecstasy:Object>) {sig=AsType maskAs(Ecstasy:Type<Ecstasy:Object>), impl=Implicit}
  [20] (v) Method{name=y#extends_, signature=Ecstasy:Boolean extends_(Ecstasy:Class)}=Ecstasy:Boolean extends_(Ecstasy:Class)
    [*] Referent.extends_(Ecstasy:Class) {sig=Ecstasy:Boolean extends_(Ecstasy:Class), impl=Implicit}
  [21] Method{name=x#equals, signature=Ecstasy:Boolean equals(Ecstasy:Object, Ecstasy:Object)}=Ecstasy:Boolean equals(Ecstasy:Object, Ecstasy:Object)
    [0] Object.equals(Ecstasy:Object, Ecstasy:Object) {sig=Ecstasy:Boolean equals(Ecstasy:Object, Ecstasy:Object), impl=Explicit}
  [22] Method{name=x#equals, signature=Ecstasy:Boolean equals(Ecstasy:Ref, Ecstasy:Ref)}=Ecstasy:Boolean equals(Ecstasy:Ref, Ecstasy:Ref)
    [*] Ref.equals(Ecstasy:Ref, Ecstasy:Ref) {sig=Ecstasy:Boolean equals(Ecstasy:Ref, Ecstasy:Ref), impl=Default}
  [23] (v) Method{name=y#implements_, signature=Ecstasy:Boolean implements_(Ecstasy:Class)}=Ecstasy:Boolean implements_(Ecstasy:Class)
    [*] Referent.implements_(Ecstasy:Class) {sig=Ecstasy:Boolean implements_(Ecstasy:Class), impl=Implicit}
  [24] (v) Method{name=x#incorporates_, signature=Ecstasy:Boolean incorporates_(Ecstasy:Class)}=Ecstasy:Boolean incorporates_(Ecstasy:Class)
    [*] Referent.incorporates_(Ecstasy:Class) {sig=Ecstasy:Boolean incorporates_(Ecstasy:Class), impl=Implicit}
  [25] (v) Method{name=y#instanceOf, signature=Ecstasy:Boolean instanceOf(Ecstasy:Type)}=Ecstasy:Boolean instanceOf(Ecstasy:Type)
    [*] Referent.instanceOf(Ecstasy:Type) {sig=Ecstasy:Boolean instanceOf(Ecstasy:Type), impl=Implicit}
  [26] (v) Method{name=y#get, signature=Ecstasy:Ref.RefType get()}=Ecstasy:Int64 get()
    [*] Ref.get() {sig=Ecstasy:Int64 get(), impl=Implicit}
  [27] (v) Method{name=y#get, signature=Ecstasy:annotations.LazyVar.RefType get()}=Ecstasy:Int64 get()
    [0] annotations.LazyVar.get() {sig=Ecstasy:Int64 get(), impl=Explicit}
  [28] (v) Method{name=y#peek, signature=(Ecstasy:Boolean, Ecstasy:Ref.RefType) peek()}=(Ecstasy:Boolean, Ecstasy:Int64) peek()
    [*] Ref.peek() {sig=(Ecstasy:Boolean, Ecstasy:Int64) peek(), impl=Implicit}
  [29] (v) Method{name=y#revealAs, signature=(Ecstasy:Boolean, AsType) revealAs(Ecstasy:Type<Ecstasy:Object>)}=(Ecstasy:Boolean, AsType) revealAs(Ecstasy:Type<Ecstasy:Object>)
    [*] Referent.revealAs(Ecstasy:Type<Ecstasy:Object>) {sig=(Ecstasy:Boolean, AsType) revealAs(Ecstasy:Type<Ecstasy:Object>), impl=Implicit}
  [30] (v) Method{name=to, signature=Ecstasy:String to()}=Ecstasy:String to()
    [*] Object.to() {sig=Ecstasy:String to(), impl=Implicit}
    [0] Object.to() {sig=Ecstasy:String to(), impl=Explicit}
  [31] (v) Method{name=to, signature=Ecstasy:collections.Array<this:class> to()}=Ecstasy:collections.Array<this:class> to()
    [*] Object.to() {sig=Ecstasy:collections.Array<this:class> to(), impl=Implicit}
    [0] Object.to() {sig=Ecstasy:collections.Array<this:class> to(), impl=Explicit}
  [32] (v) Method{name=to, signature=Ecstasy:collections.Tuple<this:class> to()}=Ecstasy:collections.Tuple<this:class> to()
    [*] Object.to() {sig=Ecstasy:collections.Tuple<this:class> to(), impl=Implicit}
    [0] Object.to() {sig=Ecstasy:collections.Tuple<this:class> to(), impl=Explicit}
  [33] (v) Method{name=to, signature=Ecstasy:Function<Ecstasy:collections.Tuple<this:class>, Ecstasy:collections.Tuple> to()}=Ecstasy:Function<Ecstasy:collections.Tuple<this:class>, Ecstasy:collections.Tuple> to()
    [*] Object.to() {sig=Ecstasy:Function<Ecstasy:collections.Tuple<this:class>, Ecstasy:collections.Tuple> to(), impl=Implicit}
    [0] Object.to() {sig=Ecstasy:Function<Ecstasy:collections.Tuple<this:class>, Ecstasy:collections.Tuple> to(), impl=Explicit}
  [34] (v) Method{name=x#maskAs, signature=AsType maskAs(Ecstasy:Type<Ecstasy:Object>)}=AsType maskAs(Ecstasy:Type<Ecstasy:Object>)
    [*] Referent.maskAs(Ecstasy:Type<Ecstasy:Object>) {sig=AsType maskAs(Ecstasy:Type<Ecstasy:Object>), impl=Implicit}
  [35] (v) Method{name=y#to, signature=Ecstasy:String to()}=Ecstasy:String to()
    [*] Object.to() {sig=Ecstasy:String to(), impl=Implicit}
  [36] (v) Method{name=y#to, signature=Ecstasy:collections.Array<this:class> to()}=Ecstasy:collections.Array<this:class> to()
    [*] Object.to() {sig=Ecstasy:collections.Array<this:class> to(), impl=Implicit}
  [37] (v) Method{name=y#to, signature=Ecstasy:collections.Tuple<this:class> to()}=Ecstasy:collections.Tuple<this:class> to()
    [*] Object.to() {sig=Ecstasy:collections.Tuple<this:class> to(), impl=Implicit}
  [38] (v) Method{name=y#to, signature=Ecstasy:Function<Ecstasy:collections.Tuple<this:class>, Ecstasy:collections.Tuple> to()}=Ecstasy:Function<Ecstasy:collections.Tuple<this:class>, Ecstasy:collections.Tuple> to()
    [*] Object.to() {sig=Ecstasy:Function<Ecstasy:collections.Tuple<this:class>, Ecstasy:collections.Tuple> to(), impl=Implicit}