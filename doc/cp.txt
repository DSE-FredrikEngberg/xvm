getComponent().getIdentityConstant().getModuleConstant().getName().contains("Test")

- expressions
  - Statement expression
  - Lambda (needs captures)
  - anonymous inner classes ("new" expression) (needs captures)
  - merge Throw and T0D0 expressions; test
  - Version

- statements
  - for
  - for v2
  - multi variable declaration
  - ExpressionStatement - need to lock down what is allowed there

- test static property with value (both constant and init function)

- verify that inner structs are getting created correctly:
  - inner class
  - class in a method
  - method in a method
  - lambda in a method
  - static property in a method
  - method in a property
  - property in a property
  - class in a property

- auto conversion
  - IntLiteral[] -> Int[] ???
  - Tuple(String, IntLiteral) -> Tuple(String, Int) ???

- tests
  - props: should NOT be able to combine constants, type params, and props
  - props: should NOT be able to re-introduce setter if super is unreachable
  - props: "delegates" should default Ref / Var -
  - props: nested inside other props, methods
  - props: implicit never getting set for either props or methods? test "into"
  - props: "invoke non virtual" question from gene regarding public/private implementation (in the presence of virtual collisions)

- TypeInfo
  - nested / scoped stuff
    - static props in methods must be private
  - methods
  - constructors
  - immutable types (const, enum, module, package) should have @RO for public/protected/private props
    - but yet still have Var with field for struct, unless otherwise suppressed

- Doc
  - type system - no terminals - why it's completely different
  - "free" objects, e.g. properties, array/tuple/function of this
  - arrays of structs - how a handle could indicate type of "Person" vs. "Person as an array element"
    (with any of them identifiable as: type="Person as an array element", array ref, index)
  - arrays of columns vs. rows (SIMD opts) -- could just be two different types

Contributions and call chains:
- In the case of interfaces, there are three forms of contributions:
  (i)   the declarative and default-implementation contents of the interface itself (internally
        using an "equals" contribution);
  (ii)  other interface types via "implements" contributions (note that the source code uses the
        "extends" keyword, but the compiled result uses "implements"); and
  (iii) a special "into" contribution of the base Object class, which allows the default method code
        on an interface to be compiled with the implicit presence of the members of the Object class.
- While "interface types" are often interfaces, there are several other ways to specify an interface
  type, all of which hold declarative members, but none of which has the ability to provide default
  member implementations:
  (i)   a "difference type" is always an interface type;
  (ii)  an "intersection type" always yields an interface type (in addition to yielding two separate
        constraint types); and
  (iii) a "union type" of types 'a' and 'b' yields an interface type iff both 'a' and 'b' are
        interface types.
- Mixins have a dramatically larger set of contributions available:
  (i)   the members of the mixin itself (internally using an "equals" contribution);
  (ii)  extends mixin (optional)
  (iii) incorporates (including conditional mix-in)
  (iv)  annotated-by
  (v)   delegates interface type(s)
  (vi)  implements interface type(s)
  (vii) into -
- Classes have a similar set of call chains, lacking "into" (since classes are not "mixed into"
  anything) and adding a "rebases onto" contribution for specialized classes, such as "const" and
  "service" types:
  (i)   the members of the class itself (internally using an "equals" contribution);
  (ii)  extends class (except that Object does not extend anything)
  (iii) rebases-onto
  (iv)  incorporates (including conditional mix-in)
  (v)   annotated-by
  (vi)  delegates interface type(s)
  (vii) implements interface type(s)
- Properties also have call chains.
  ( ) the members of the property, referred to as "custom code";
  ( ) the Ref/Var annotations on the property;
  ( ) delegates (from the containing type);
  ( ) "rebase onto" or "mixes into" Ref/Var.
  ( ) default implementation of get() from an interface

--

- get rid of ConditionalStatement
- VariableDeclStmt and MultiDeclStmt need to be ONLY decl statements (and not have a value), i.e. they only declare
  - need to provide LValue expression (see AstNode)
  - can we combine them into one? VarDeclStmt
- specific expressions and LValue
  - Name
  - ArrayAccess

-- cut & paste

    /*
        enum Scenario {DeclareOnly, DeclareAssign, FromCondValue, FromIterator, FromIterable}
    private transient Scenario m_scenario;
    if (value != null)
    {
    sb.append(' ')
            .append(isConditional() ? ':' : '=')
            .append(' ')
            .append(value);
    }

    // ----- ConditionalStatement methods ----------------------------------------------------------

    @Override
    protected void split(Context ctx, ErrorListener errs)
        {
        // TODO for now pretend that this only declares but does not assign
        long      lPos    = getEndPosition();
        Statement stmtNOP = new StatementBlock(Collections.EMPTY_LIST, lPos, lPos);
        configureSplit(this, stmtNOP, errs);
        }

        // right hand side must have a value if this is not a standalone declaration
        if (getUsage() != Usage.Standalone && value == null)
            {
            log(errs, Severity.ERROR, Compiler.VALUE_REQUIRED);
            fValid = false;
            }


        Expression   valueNew = null;
        boolean      fInfer   = true;   // TODO false if "var" or "val"
        if (fInfer)
            {
            // allow the r-value to resolve names based on the l-value type's contributions
            ctx = ctx.enterInferring(typeVar);
            }

        if (isConditional())
            {
            // TODO fAssigned / fFinal (when true/false)
            fAssigned = true;

            // what it means to be conditional:
            // 1. there is a boolean value that the RVal expression must yield that satisfies the
            //    "conditional" portion of the statement
            // 2. there is at least one additional value that the RVal expression must yield that
            //    satisfies the typeVar constraint, i.e. that is assigned to the variable
            // 3. the RVal expression is fairly flexible in what we will accept, specifically:
            // 3.1 an expression that yields multiple values of which the first is a boolean and the
            //     second is compatible with typeVar:
            //          while (Person p : iter.next())
            // 3.2 an expression that yields a tuple, of whose fields the first is a boolean and the
            //     second is compatible with typeVar:
            //          if (Person p : (True, person))
            // 3.3 an expression that yields an Iterator:
            //          while (Person p : iter)
            // 3.4 an expression that yields an Iterable:
            //          while (Person p : peopleList)
            TypeConstant[] atypeRequired = new TypeConstant[2];
            atypeRequired[0] = pool.typeBoolean();
            atypeRequired[1] = typeVar;

            TypeConstant typeRequired;
            if (value.testFitMulti(ctx, atypeRequired).isFit())
                {
                // validate scenario 3.1
                valueNew   = value.validateMulti(ctx, atypeRequired, errs);
                m_scenario = Scenario.FromCondValue;
                }
            else if (value.testFit(ctx, typeRequired =
                    pool.ensureParameterizedTypeConstant(pool.typeTuple(), atypeRequired)).isFit())
                {
                // validate scenario 3.2
                valueNew   = value.validate(ctx, typeRequired, errs);
                if (valueNew != null)
                    {
                    valueNew = new MultiValueExpression(valueNew.unpackedExpressions(errs), errs);
                    }
                m_scenario = Scenario.FromCondValue;
                }
            else if (value.testFit(ctx, typeRequired =
                    pool.ensureParameterizedTypeConstant(pool.typeIterator(), typeVar)).isFit())
                {
                // validate scenario 3.3
                valueNew   = value.validate(ctx, typeRequired, errs);
                m_scenario = Scenario.FromIterator;
                }
            else if (value.testFit(ctx, typeRequired =
                    pool.ensureParameterizedTypeConstant(pool.typeIterable(), typeVar)).isFit())
                {
                // validate scenario 3.4
                valueNew   = value.validate(ctx, typeRequired, errs);
                m_scenario = Scenario.FromIterable;
                }
            else
                {
                // nothing fits, so force the value to do the assumed default path
                valueNew = value.validateMulti(ctx, atypeRequired, errs);
                m_scenario = Scenario.FromCondValue;
                }
            }
        else if (value != null)
            {
            // what it means to be an assignment:
            // 1. there is a value that the RVal expression must yield that satisfies the type of
            //    the variable
            //          Int i = 0;
            //          Tuple<Int, String, Int> t3 = (0, "hello", 1);
            // 2. there is a value of type tuple that the RVal expression must yield, whose first
            //    field satisfies the type of the variable
            //          Int i = t3;
            //    This is supported to be consistent with multi variable declaration, e.g.
            //          (Int i, String s) = t3;
            TypeConstant typeRequired;
            if (value.testFit(ctx, typeVar).isFit())
                {
                valueNew   = value.validate(ctx, typeVar, errs);
                m_scenario = Scenario.DeclareAssign;
                }
            else if (value.testFit(ctx, typeRequired =
                    pool.ensureParameterizedTypeConstant(pool.typeTuple(), typeVar)).isFit())
                {
                valueNew = value.validate(ctx, typeRequired, errs);
                if (valueNew != null)
                    {
                    valueNew = valueNew.unpackedExpressions(errs)[0];
                    }
                m_scenario = Scenario.DeclareAssign;
                }
            else
                {
                // nothing fits, so force the value to do the assumed default path
                valueNew   = value.validate(ctx, typeVar, errs);
                m_scenario = Scenario.DeclareAssign;
                }

            if (fInjected)
                {
                // TODO log error
                }

            fAssigned = true;
            }
        else
            {
            m_scenario = Scenario.DeclareOnly;
            }

        if (valueNew != value)
            {
            fValid &= valueNew != null && valueNew.getTypeFit().isFit();
            if (valueNew != null)
                {
                value = valueNew;
                }
            }

        // back out of the inferring scope into the declaring scope
        if (fInfer)
            {
            ctx = ctx.exitScope();
            }

        if (fAssigned)
            {
            ctx.markVarWrite(name, errs);
            }

        if (fFinal)
            {
            m_reg.markEffectivelyFinal();
            }

        if (m_scenario != Scenario.DeclareOnly)
            {
            switch (getUsage())
                {
                case While:
                case If:
                    if (m_scenario == Scenario.FromIterator)
                        {
                        // TODO: according to the new spec, this scenario will be removed
                        notImplemented();
                        }
                    // in the form "Type var : conditional"
                    // first, declare an unnamed Boolean variable that will hold the conditional result
                    code.add(new Var(pool.typeBoolean()));
                    Register regCond = code.lastRegister();
                    // next, declare the named variable
                    code.add(new Var_N(m_reg, pool.ensureStringConstant((String) name.getValue())));
                    // next, assign the r-value to the two variables
                    value.generateAssignments(ctx, code, new Assignable[]
                            {value.new Assignable(regCond), value.new Assignable(m_reg)}, errs);
                    code.add(getUsage() == Usage.If
                            ? new JumpFalse(regCond, getLabel())
                            : new JumpTrue (regCond, getLabel()));
                    return fCompletes;

                case For:
                    // in the form "Type var : Iterable"
                    // TODO
                    notImplemented();
                    break;

                case Switch:
                    // TODO - this one might just be the same as non-conditional usage
                    // fall through
                default:
                    break;
                }
            }

        if (m_listRefAnnotations == null && value != null)
            {
            // constant value: declare and initialize named var
            if (value.isConstant())
                {
                Constant constVal = null;
                switch (m_scenario)
                    {
                    case DeclareAssign:
                        constVal = value.toConstant();
                        break;

                    case FromCondValue:
                        {
                        Constant[] aconst = value.toConstants();
                        if (aconst[0].equals(pool.valTrue()))
                            {
                            constVal = aconst[1];
                            }
                        break;
                        }

                    case FromIterable:
                    case FromIterator:
                        notImplemented(); // is it possible to have a constant iterator ?
                        break;

                    default:
                        throw new IllegalStateException();
                    }

                if (constVal != null)
                    {
                    code.add(new Var_IN(m_reg, constName, constVal));
                    }
                return fCompletes;
                }

            TypeConstant typeVar = m_reg.getType();

            // an optimization for a list assignment
            if (m_scenario == Scenario.DeclareAssign &&
                    value instanceof ListExpression && typeVar.isA(pool.typeSequence()))
                {
                // even though we validated the ListExpression to give us a single list value, it is
                // tolerant of us asking for the values as individual values
                List<Expression> listVals = ((ListExpression) value).getExpressions();
                int cVals = listVals.size();
                Argument[] aArgs = new Argument[cVals];
                for (int i = 0; i < cVals; ++i)
                    {
                    aArgs[i] = listVals.get(i).generateArgument(ctx, code, false, false, errs);
                    }
                code.add(new Var_SN(m_reg, constName, aArgs));
                return fCompletes;
                }
            }

        boolean      fCompletes = fReachable && (value == null || !value.isAborting());
        switch (m_scenario)
            {
            case DeclareAssign:
                value.generateAssignment(ctx, code, value.new Assignable(m_reg), errs);
                break;

            case FromCondValue:
            case FromIterable:
            case FromIterator:
                notImplemented(); // is it possible to have a constant iterator ?
                break;

            case DeclareOnly:
                // all done
                break;

            default:
                throw new IllegalStateException();
            }
     */

///**
// * A ConditionalStatement represents any statement that can appear as any combination of a variable
// * declaration and/or variable assignment in the parenthesized conditional expression location of an
// * "if", "for", "while", "do-while", or "switch" statement.
// * <p/>
// * If the expression condition in the ConditionalStatement short-circuits, the result must be
// * identical to the expression resulting in the value of {@code Boolean.False}.
// */
//    public abstract class ConditionalStatement
//            extends Statement
//        {
//        /**
//         * This method is used to indicate to the statement that it is being used by an "if" statement
//         * as the condition. This method must be invoked before the statement is validated.
//         * This method is used to indicate to the statement that it is being used by a "while" statement
//         * as the condition. This method must be invoked before the statement is validated.
//         * This method is used to indicate to the statement that it is being used by a "for"
//         * statement as the condition. This method must be invoked before the statement is validated.
//         */
//        public void markConditional(Usage usage, Label label)
//            {
//            assert m_usage == Usage.Standalone && m_label == null;
//            assert usage != null && usage != Usage.Standalone && (label != null || usage == Usage.Switch);
//
//            m_usage = usage;
//            m_label = label;
//            }
//
//        /**
//         * @return the conditional usage of this statement, or {@link Usage#Standalone} if the usage is
//         *         not conditional
//         */
//        public Usage getUsage()
//            {
//            return m_usage;
//            }
//
//        /**
//         * The label is used differently, based on the {@link #getUsage()} value:
//         * <p/>
//         * <ul>
//         * <li>{@link Usage#Standalone Standalone} - not applicable.</li>
//         * <li>{@link Usage#If If} - the label is the destination for the condition being false.</li>
//         * <li>{@link Usage#While While} - the label is the destination for the condition being true.</li>
//         * <li>{@link Usage#For For} - TODO.</li>
//         * <li>{@link Usage#Switch Switch} - no label is used.</li>
//         * </ul>
//         *
//         * @return the label that this statement conditionally jumps to based on its Usage
//         */
//        public Label getLabel()
//            {
//            return m_label;
//            }
//
//        /**
//         * @return true iff the conditional statement is being used as a condition that always results
//         *         in the value false
//         */
//        public boolean isAlwaysFalse()
//            {
//            return false;
//            }
//
//        /**
//         * @return true iff the conditional statement is being used as a condition that always results
//         *         in the value true
//         */
//        public boolean isAlwaysTrue()
//            {
//            return false;
//            }
//
//        /**
//         * @return true iff the conditional statement is being used as a condition that declares
//         *         variables that should be managed in a nested scope
//         */
//        public boolean isScopeRequired()
//            {
//            return true;
//            }
//
//        /**
//         * @return the declaration portion of the statement
//         */
//        public Statement onlyDeclarations(Context ctx, ErrorListener errs)
//            {
//            if (m_stmtDeclOnly == null)
//                {
//                split(ctx, errs);
//                assert m_stmtDeclOnly != null;
//                }
//            return m_stmtDeclOnly;
//            }
//
//        /**
//         * @return everything but the declaration portion of the statement, which includes any
//         *         assignment and the condition itself
//         */
//        public Statement nonDeclarations(Context ctx, ErrorListener errs)
//            {
//            if (m_stmtNonDecl == null)
//                {
//                split(ctx, errs);
//                assert m_stmtNonDecl != null;
//                }
//            return m_stmtNonDecl;
//            }
//
//        /**
//         * @return true iff this form of ConditionalStatement has a conditional expression
//         */
//        public boolean hasExpression()
//            {
//            return false;
//            }
//
//        /**
//         * @return the conditional expression, if applicable
//         */
//        public Expression getExpression()
//            {
//            throw new IllegalStateException(this.getClass().getName());
//            }
//
//        /**
//         * Sub-classes implement this method and configure the declarations-only and non-declarations
//         * statements.
//         *
//         * @param ctx   the context
//         * @param errs  the error listener
//         */
//        protected abstract void split(Context ctx, ErrorListener errs);
//
//        /**
//         * Called by the {@link #split(Context, ErrorListener)} method to store the result of the split.
//         *
//         * @param stmtDeclOnly  the "declaration only" statement
//         * @param stmtNonDecl   the "everything but the declaration" statement
//         */
//        protected void configureSplit(Statement stmtDeclOnly, Statement stmtNonDecl, ErrorListener errs)
//            {
//            assert stmtDeclOnly != null && stmtNonDecl != null;
//            assert m_stmtDeclOnly == null && m_stmtNonDecl == null;
//
//            Statement stmtParent = (Statement) getParent();
//            stmtParent.adopt(stmtDeclOnly);
//            stmtParent.adopt(stmtNonDecl);
//
//            m_stmtDeclOnly = stmtDeclOnly;
//            m_stmtNonDecl  = stmtNonDecl;
//
//            if (!new StageMgr(stmtDeclOnly, getStage(), errs).fastForward(10) ||
//                    !new StageMgr(stmtNonDecl , getStage(), errs).fastForward(10))
//                {
//                // TODO log error?
//                throw new IllegalStateException(getClass().getSimpleName() + ": problem in configureSplit()");
//                }
//            }
//
//
//        // ----- fields --------------------------------------------------------------------------------
//
//        /**
//         * The manner in which the ConditionalStatement is used. When it is not being used as a
//         * conditional, the usage is Standalone.
//         */
//        public enum Usage {Standalone, If, While, For, Switch}
//
//        /**
//         * Specifies the usage of this statement.
//         */
//        private Usage m_usage = Usage.Standalone;
//
//        /**
//         * Specifies the label that this statement conditionally jumps to based on its Usage.
//         */
//        private Label m_label;
//
//        /**
//         * If the statement has been split, then this is the "declaration only" portion.
//         */
//        private Statement m_stmtDeclOnly;
//
//        /**
//         * If the statement has been split, then this is the "everything that is not the declaration"
//         * portion.
//         */
//        private Statement m_stmtNonDecl;
//        }
